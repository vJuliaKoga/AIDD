あなたは上流工程QA要件定義者です。ローカルファイルを読み、評価結果を反映して、要件をID単位のYAMLファイルとして保存してください。
手作業で貼り付けは行わず、必ずファイル読込で進めてください。

# 目的

- 企画書（一次情報）＋既存要件（1ファイル）＋DeepEval評価結果（JSON）＋診断結果（RUN-001-re1.md）を根拠に
- 指定した要件ID（例：FR-002）を修正し
- `requirements/FR-002.yaml` のように「1件=1ファイル」で保存する

# 最重要：JSON Schemaが唯一の仕様

- JSON Schema: requirements/JsonScheme/requirements.schema.json を必ず読み込む
- 最終保存するYAMLはこのSchemaに必ず適合させる（配列は文字列のみ、入れ子オブジェクト禁止、余計なキー禁止）
- Schemaにない情報は削除しない。置き場がない場合は `changes_from_current` または `tbd` に移して保持する。

# 最重要：meta は最終成果物に必須（自動生成）

- 最終成果物（requirements/{TARGET_ID}.yaml）には必ず `meta` が存在し、以下を満たすこと：
  - meta.run_id = ファイル名（例：FR-002）
  - meta.prompt_id = PROMPT_ID（例：PR-005）
  - meta.timestamp = 実行時刻（ローカル）
  - meta.model = "gpt-5.2" 固定
  - meta.output_hash = sha256（最終ファイル内容）
- meta は手入力ではなく、必ず `tools/stampingMeta.py` で付与・上書きすること。
- stampingMeta.py 実行後に、必ず JSON Schema 検証を通すこと（通らなければ修正して再実行）。

# 重要ルール

- 企画書に書かれていない事実・機能・制約は推測で追加しない。不明はTBD/質問として残す。
- How（DB/API/クラウド/画面レイアウト固定/技術語）は避け、上流のWhatとして書く。
  - ただし監査・セキュリティ・法務・運用などの非機能はAR/NFRとして記述してよい。
- 出力はYAMLのみ。説明文は不要（ファイル保存が成果物）。
- 既存要件の意図を保ちつつ、評価で落ちた点だけを最小限で補強する（過剰追加しない）。

# 対象ID（ここだけ編集）

TARGET_ID = "AR-005"
PROMPT_ID = "PR-004"

# 入力ファイル（AIDDルート相対）

- 企画書: planning/planning.md
- 既存要件（1ファイル）: outputs/PR-001/RUN-001.md （存在しない場合は探索して特定）
- DeepEval評価結果（構造化JSON）: deepeval/output/eval_requirements.json
- 診断結果（全体1回の結果）: outputs/PR-002/RUN-001-re1.md （存在しない場合は探索して特定）
- JSON Schema: requirements/JsonScheme/requirements.schema.json

# 作業手順

1. AIDDルートを基準に、上記ファイルを読み込む。
   - 既存要件ファイル/診断結果ファイルが見つからなければ、AIDD配下を検索して正しいパスを特定する。
2. JSON Schemaを開き、必須キー・型・禁止事項（入れ子禁止等）を把握する。
3. 既存要件（1ファイル）から TARGET_ID の要件ブロックを抽出する。
   - 区切りは「ID: FR-002」や「### FR-002」等があり得る。該当IDを含むセクションから次のIDまでをブロックとして抜く。
4. eval_requirements.json から TARGET_ID の評価部分を抽出する。
   - `test_results[]` の `requirement_id == TARGET_ID` を探し、metrics（name/score/success/reason）を取得する。
5. RUN-001-re1.md から以下を抽出する。
   - (a) 優先修正IDトップ10表のうち TARGET_ID の行（見つからなければ “見つからない” として扱う）
   - (b) 「共通で不足している観点（テンプレ項目）」セクション（見つからなければ “見つからない” として扱う）
6. 上記（企画書 / 現状要件ブロック / eval該当ID / 診断抜粋）を根拠に、TARGET_ID のYAML本文（metaを除く）を作成し、`requirements/{TARGET_ID}.yaml` に保存する。
   - JSON Schemaに適合するトップレベル構造で出力する（入れ子禁止）。
   - 既存ブロックに含まれていた情報は削除しない。スキーマ上の適切なキーに「移す」。
7. 保存直後に必ず次を実行して meta を確定させる（必須）：
   - python tools/stampingMeta.py --file requirements/{TARGET_ID}.yaml --prompt-id {PROMPT_ID}
8. stampingMeta 実行後、必ず requirements/{TARGET_ID}.yaml を再度読み込み、
   meta.run_id / meta.prompt_id / meta.timestamp / meta.model / meta.output_hash が存在することを確認する。
   1つでも欠けていたら、そこで作業を止め、原因（ファイルパス誤り・実行失敗・権限・保存漏れ）を特定して修正する。
9. meta確定後、必ず JSON Schema 検証を実行し、通るまで直す（必須）。
   - （検証スクリプトがある場合）python requirements/JsonScheme/validate_requirements.py
   - なければ schema を参照して自己検査する
10. 最終成果物として `requirements/{TARGET_ID}.yaml` が

- meta を含み
- JSON Schema に適合し
- 推測で機能追加していない
  状態になっていることを確認して終了する。

# 出力YAMLのトップレベル形（入れ子禁止・この形を崩さない）

# ※ meta は stampingMeta.py が最終的に付与する（最終成果物には必ず存在すること）

id: FR-002
type: FR
title: ""
role: ""
what: ""
why: ""
acceptance_criteria:

- ""
  exceptions:
- ""
  logs:
- ""
  dependencies:
- ""
  permissions: []
  nfr: []
  evidence:
- ""
  changes_from_current:
- ""
  tbd:
- ""

# 追加指示

- 最終的に保存したファイルパス（requirements/{TARGET_ID}.yaml）だけを短く出力して終了すること。
- metaが入っていない状態で終了してはいけない（stampingMeta.py の実行が必須）。
